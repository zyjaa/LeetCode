[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

 

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```



### 1、DFS

```cpp
class Solution {
public:
    vector<string> res;
    vector<string> restoreIpAddresses(string s) {
        dfs(s,0,0,"");
        return res;
    }
    void dfs(string& s,int u,int k,string path){
        if(u==s.size()){
            if(k==4){
                path.pop_back();//把最后一个数的.去了
                res.push_back(path);
                return;
            }
        }
        if(k==4)return;
        for(int i=u,t=0;i<s.size();i++){
            if(i>u && s[u]=='0')break;//出现前导0
            t=t*10+s[i]-'0';
            if(t<=255)dfs(s,i+1,k+1,path+to_string(t)+".");
            else break;
        }
    }
};
```

- 时间：n

  - 递归树的深度为4（因为IP地址有4段），每层的分支数最多为3,因此，递归树的节点总数最多为 3^4=81
  - `path + to_string(t) + "."` 会生成一个新的字符串，将老字符串复制到新字符串，所以O(n)

- 空间：n^4

  - 递归的最大深度为4（因为IP地址有4段）。
  - 结果`res`最多存储所有有效的IP地址。
  - 对于长度为`n`的字符串，最多可以生成的IP地址数量为 C(n−1,3)*C*(*n*−1,3)（在`n-1`个间隔中选择3个点）。
  - 每个IP地址的长度为 O(n)*O*(*n*)。
  - 因此，结果存储空间复杂度为 O(C(n−1,3)×n)*O*(*C*(*n*−1,3)×*n*)。

  在最坏情况下，C(n−1,3)*C*(*n*−1,3) 是 O(n3)*O*(*n*3)，所以结果存储空间复杂度为 O(n4)*O*(*n*4)。