### 1、DP

将一个字符串 `s` 分割成 `m` 个回文子串，并返回使这些子串成为回文串所需的最小修改次数。

```cpp
class Solution {
public:
    int palindromePartition(string s, int m) {
        int n = s.size(); // 字符串的长度
        const int INF = 1e8; // 定义一个很大的数，表示无穷大

        // 预处理 cost 数组
        // cost[i][j] 表示将子串 s[i..j] 变成回文串所需的最小修改次数
        vector<vector<int>> cost(n, vector<int>(n, 0));
        for (int len = 2; len <= n; len++) { // 枚举子串的长度
            for (int i = 0; i + len - 1 < n; i++) { // 枚举子串的起始位置
                int j = i + len - 1; // 子串的结束位置
                // 状态转移方程：
                // cost[i][j] = cost[i+1][j-1] + (s[i] != s[j])
                // 即：如果 s[i] != s[j]，则需要修改一次，否则不需要
                cost[i][j] = cost[i + 1][j - 1] + (s[i] != s[j]);
            }
        }

        // 初始化动态规划数组 f
        // f[i][j] 表示将前 i 个字符分割成 j 个回文子串所需的最小修改次数
        vector<vector<int>> f(n, vector<int>(m + 1, INF));
        for (int i = 0; i < n; i++) {
            // 将前 i 个字符分割成 1 个回文子串的修改次数就是 cost[i]
            f[i][1] = cost[0][i];
        }

        // 动态规划求解
        for (int j = 2; j <= m; j++) { // 枚举分割的子串数量 j
            for (int i = 0; i < n; i++) { // 枚举字符串的结束位置 i
                for (int k = i; k >= j - 1; k--) { // 枚举分割点 k
                    // 状态转移方程：
                    // f[i][j] = min(f[i][j], f[k-1][j-1] + cost[k][i])
                    // 即将前 k-1 个字符分割成 j-1 个子串，加上将 s[k..i] 变成回文串的修改次数
                    f[i][j] = min(f[i][j], (k > 0 ? f[k - 1][j - 1] : 0) + cost[k][i]);
                }
            }
        }

        // 返回将整个字符串分割成 m 个回文子串所需的最小修改次数
        return f[n - 1][m];
    }
};
```

- 为什么在外层？
  - 因为我们需要先解决将字符串分割成较少子串的问题，再逐步解决分割成更多子串的问题。
  - 例如，计算 `f[i][j]` 时，需要用到 `f[k-1][j-1]`，即分割成 `j-1` 个子串的解。因此，必须先计算 `j-1` 的情况，再计算 `j` 的情况。

- 为什么在中层？
  - 对于每个固定的分割数量 `j`，我们需要计算所有可能的子串 `s[0..i]` 的分割方案。
  - 由于 `f[i][j]` 依赖于 `f[k-1][j-1]`，而 `k` 的范围是 `[j-1, i]`，所以需要先计算较小的 `i`，再计算较大的 `i`。

1. - 为什么在最内层？
     - 对于每个固定的 `j` 和 `i`，我们需要尝试所有可能的分割点 `k`，找到使 `f[i][j]` 最小的方案。
     - 由于 `k` 的范围是 `[j-1, i]`，因此需要遍历所有可能的 `k`。





