38、外观数列

「外观数列」是一个数位字符串序列，由递归公式定义：

- `countAndSay(1) = "1"`
- `countAndSay(n)` 是 `countAndSay(n-1)` 的行程长度编码。

[
行程长度编码](https://baike.baidu.com/item/行程长度编码/2931940)（RLE）是一种字符串压缩方法，其工作原理是通过将连续相同字符（重复两次或更多次）替换为字符重复次数（运行长度）和字符的串联。例如，要压缩字符串 `"3322251"` ，我们将 `"33"` 用 `"23"` 替换，将 `"222"` 用 `"32"` 替换，将 `"5"` 用 `"15"` 替换并将 `"1"` 用 `"11"` 替换。因此压缩后字符串变为 `"23321511"`。

给定一个整数 `n` ，返回 **外观数列** 的第 `n` 个元素。

**示例 1：**

**输入：**n = 4

**输出：**"1211"

**解释：**

countAndSay(1) = "1"

countAndSay(2) = "1" 的行程长度编码 = "11"

countAndSay(3) = "11" 的行程长度编码 = "21"

countAndSay(4) = "21" 的行程长度编码 = "1211"

**示例 2：**

**输入：**n = 1

**输出：**"1"

**解释：**

这是基本情况。

 

**提示：**

- `1 <= n <= 30`

 

**进阶：**你能迭代解决该问题吗？



### 法一：模拟

```cpp
class Solution {
public:
    string countAndSay(int n) {
        string s = "1"; // 初始状态
        for (int i = 0; i < n - 1; i++) { // 迭代 n-1 次
            string t = "";
            for (int j = 0; j < s.size(); j++) {
                int k = j + 1;
                while (k < s.size() && s[k] == s[j]) k++; // 统计相同字符的个数
                t += to_string(k - j) + s[j]; // 生成下一项
                j = k - 1; // 跳过已处理的字符
            }
            s = t; // 更新当前字符串
        }
        return s;
    }
};
```

- **时间复杂度**：O(n⋅m)
  - **外层循环**：执行 n−1*n*−1 次。
  - **内层循环**：每次遍历字符串 s**，复杂度为 O(len(s))。
  - **总复杂度**：O(n⋅m)，其中 m 是字符串 `s` 的最大长度。
- **空间复杂度**：O(m)
  - 存储临时字符串 t，最大长度为 O(m)